#include "ClapTrap.hpp"
#include "Colors.hpp"

ClapTrap::ClapTrap() : _name(""), _hitPoints(10), _energyPoints(10), _attackDamage(0)  {
	std::cout << BOLD_GREEN << "Default constructor called. A new ClapTrap is born!" << RESET << std::endl;
}

ClapTrap::ClapTrap(std::string name) : _name(name), _hitPoints(10), _energyPoints(10), _attackDamage(0) {
	std::cout << BOLD_GREEN << "Constructor for " << BOLD_CYAN << name << RESET << BOLD_GREEN << " called. Ready to rumble!" << RESET << std::endl;
}

ClapTrap::~ClapTrap() {
	std::cout << BOLD_RED << "Destructor called. ClapTrap signing off!" << RESET << std::endl;
}

ClapTrap::ClapTrap(ClapTrap& copy) {
	std::cout << BOLD_YELLOW << "Copy constructor called. Cloning " << BOLD_CYAN << copy._name << RESET << BOLD_YELLOW << "!" << RESET << std::endl;
	this->_name = copy._name;
	this->_hitPoints = copy._hitPoints;
	this->_energyPoints = copy._energyPoints;
	this->_attackDamage = copy._attackDamage;
}

void ClapTrap::attack(const std::string& target) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't attack!" << RESET << std::endl;
	}
	else if (this->_energyPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to attack. Time for a recharge!" << RESET << std::endl;
	}
	else {
		std::cout << BOLD_MAGENTA << this->_name << " attacks " << target << ", causing " << this->_attackDamage << " points of damage!" << RESET << std::endl;
		this->_energyPoints -= 1;
	}
}

void ClapTrap::takeDamage(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is already out. No need to kick a robot when it's down!" << RESET << std::endl;
	}
	else {
		if (amount > this->_hitPoints)
			amount = this->_hitPoints;
		this->_hitPoints -= amount;
		if (this->_hitPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_RED << this->_name << " has been destroyed! So much for warranty..." << RESET << std::endl;
		}
		else {
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << this->_name << " takes " << amount << " damage. Ouch!" << RESET << std::endl;
		}
	}
}

void ClapTrap::beRepaired(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is beyond repair. Time to build a new one!" << RESET << std::endl;
	}
	else {
		this->_hitPoints += amount;
		if (this->_hitPoints > 10)
			this->_hitPoints = 10;
		if (!this->_name.empty())
			std::cout << BOLD_GREEN << this->_name << " repairs itself and now has " << this->_hitPoints << " hit points. Back in action!" << RESET << std::endl;
	}
}

void ClapTrap::setName(std::string name) {
	this->_name = name;
}

std::string ClapTrap::getName(void) const {
	return this->_name;
}#ifndef CLAPTRAP_HPP
# define CLAPTRAP_HPP

#include <iostream>

class ClapTrap {
	protected:
		std::string _name;
		unsigned int _hitPoints;
		unsigned int _energyPoints;
		unsigned int _attackDamage;
	public:
	ClapTrap();
	ClapTrap(ClapTrap& copy);
	ClapTrap(std::string name);
	~ClapTrap();
	void attack(const std::string& target);
	void takeDamage(unsigned int amount);
	void beRepaired(unsigned int amount);
	void setName(std::string name);
	std::string getName(void) const;
};

#endif
#ifndef COLORS_HPP
# define COLORS_HPP

#define RESET "\033[0m"
#define RED "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN "\033[36m"
#define WHITE "\033[37m"
#define BOLD "\033[1m"
#define UNDERLINE "\033[4m"
#define REVERSED "\033[7m"
#define HIDDEN "\033[8m"
#define BLACK "\033[30m"
#define BOLD_RED "\033[1;31m"
#define BOLD_GREEN "\033[1;32m"
#define BOLD_YELLOW "\033[1;33m"
#define BOLD_BLUE "\033[1;34m"
#define BOLD_MAGENTA "\033[1;35m"
#define BOLD_CYAN "\033[1;36m"
#define BOLD_WHITE "\033[1;37m"
#define BG_RED "\033[41m"
#define BG_GREEN "\033[42m"
#define BG_YELLOW "\033[43m"
#define BG_BLUE "\033[44m"
#define BG_MAGENTA "\033[45m"
#define BG_CYAN "\033[46m"
#define BG_WHITE "\033[47m"
#define BG_BLACK "\033[40m"
#define BG_BOLD_RED "\033[1;41m"
#define BG_BOLD_GREEN "\033[1;42m"
#define BG_BOLD_YELLOW "\033[1;43m"
#define BG_BOLD_BLUE "\033[1;44m"
#define BG_BOLD_MAGENTA "\033[1;45m"
#define BG_BOLD_CYAN "\033[1;46m"
#define BG_BOLD_WHITE "\033[1;47m"

#endif#include "DiamondTrap.hpp"
#include "Colors.hpp"

DiamondTrap::DiamondTrap() {
	std::cout << BOLD_GREEN << "Diamond default constructor called. A new DiamondTrap is born!" << RESET << std::endl;
}

DiamondTrap::DiamondTrap(DiamondTrap& copy) {
	std::cout << BOLD_YELLOW << "DiamondTrap copy constructor called. Cloning " << BOLD_CYAN << copy._name << RESET << BOLD_YELLOW << "!" << RESET << std::endl;
	this->_name = copy._name;
}

DiamondTrap::DiamondTrap(std::string name) : ClapTrap(name + "_clap_name") {
	std::cout << BOLD_GREEN << "Diamond constructor for " << BOLD_CYAN << name << RESET << BOLD_GREEN << " called. A new DiamondTrap is born! Ready to rumble!" << RESET << std::endl;
	_name = name;
	this->_hitPoints = 100;
	this->_energyPoints = 50;
	this->_attackDamage = 30;
	std::cout << BOLD_WHITE << "DiamondTrap " << this->_name << " has " << this->_hitPoints << " hit points, " << this->_energyPoints << " energy points, and " << this->_attackDamage << " attack damage." << RESET << std::endl;
}

DiamondTrap::~DiamondTrap() {
	std::cout << BOLD_RED << "DiamondTrap destructor called. " << this->_name << " is no more." << RESET << std::endl;
}

void DiamondTrap::whoAmI() {
	std::cout << BOLD_CYAN << "I am " << this->_name << " and I am a DiamondTrap!" << RESET << std::endl;
	std::cout << BOLD_CYAN << "My ClapTrap name is " << this->ClapTrap::getName() << RESET << std::endl;
}

void DiamondTrap::attack(std::string const & target) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't attack!" << RESET << std::endl;
	}
	else if (this->_energyPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to attack. Time for a recharge!" << RESET << std::endl;
	}
	else {
		std::cout << BOLD_MAGENTA << this->_name << " attacks " << target << ", causing " << this->_attackDamage << " points of damage!" << RESET << std::endl;
		this->_energyPoints -= 1;
	}
}

void DiamondTrap::takeDamage(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is already out. No need to kick a robot when it's down!" << RESET << std::endl;
	}
	else {
		if (amount > this->_hitPoints)
			amount = this->_hitPoints;
		this->_hitPoints -= amount;
		if (this->_hitPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_RED << this->_name << " has been destroyed! So much for warranty..." << RESET << std::endl;
		}
		else {
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << this->_name << " has taken " << amount << " points of damage and has " << this->_hitPoints << " hit points left." << RESET << std::endl;
		}
	}
}

void DiamondTrap::beRepaired(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't be repaired!" << RESET << std::endl;
	}
	else {
		if (this->_energyPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to be repaired. Time for a recharge!" << RESET << std::endl;
			return ;
		}
		this->_hitPoints += amount;
		if (this->_hitPoints > 100)
			this->_hitPoints = 100;
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << this->_name << " has been repaired for " << amount << " points and now has " << this->_hitPoints << " hit points." << RESET << std::endl;
	}
}

void DiamondTrap::setEnergyPoints(unsigned int energyPoints) {
	this->_energyPoints = energyPoints;
}#ifndef DIAMONDTRAP_HPP
# define DIAMONDTRAP_HPP

#include "ScavTrap.hpp"
#include "FragTrap.hpp"

class DiamondTrap : public ScavTrap, public FragTrap {
	private:
	std::string _name;
	public:
	DiamondTrap();
	DiamondTrap(DiamondTrap& copy);
	DiamondTrap(std::string name);
	~DiamondTrap();
	void takeDamage(unsigned int amount);
	void beRepaired(unsigned int amount);
	void attack(std::string const & target);
	void setEnergyPoints(unsigned int energyPoints);
	void whoAmI();
};

#endif
#include "FragTrap.hpp"
#include "Colors.hpp"

FragTrap::FragTrap() : ClapTrap() {
	std::cout << BOLD_GREEN << "Default constructor called. A new FragTrap is born!" << RESET << std::endl;
	this->_hitPoints = 100;
	this->_energyPoints = 100;
	this->_attackDamage = 30;
}

FragTrap::FragTrap(std::string name, unsigned int hitPoints, unsigned int attackDamage) {
	std::cout << BOLD_GREEN << "Constructor for " << BOLD_CYAN << name << RESET << BOLD_GREEN << " called. A new FragTrap is born! Ready to rumble!" << RESET << std::endl;
	this->_name = name;
	this->_hitPoints = hitPoints;
	this->_attackDamage = attackDamage;
}

FragTrap::FragTrap(std::string name) : ClapTrap() {
	std::cout << BOLD_GREEN << "Constructor for " << BOLD_CYAN << name << RESET << BOLD_GREEN << " called. A new FragTrap is born! Ready to rumble!" << RESET << std::endl;
	this->_hitPoints = 100;
	this->_energyPoints = 100;
	this->_attackDamage = 30;
}

FragTrap::FragTrap(FragTrap& copy) : ClapTrap(copy) {
	std::cout << BOLD_YELLOW << "Copy constructor called. Cloning Scav the " << BOLD_CYAN << copy._name << RESET << BOLD_YELLOW << "!" << RESET << std::endl;
}

FragTrap::~FragTrap() {
	std::cout << BOLD_RED << "Destructor called. FragTrap signing off!" << RESET << std::endl;
}

void FragTrap::attack(const std::string& target) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't attack!" << RESET << std::endl;
	}
	else if (this->_energyPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to attack. Time for a recharge!" << RESET << std::endl;
	}
	else {
		std::cout << BOLD_MAGENTA << this->_name << " attacks " << target << ", causing " << this->_attackDamage << " points of damage!" << RESET << std::endl;
		this->_energyPoints -= 1;
	}
}

void FragTrap::takeDamage(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is already out. No need to kick a robot when it's down!" << RESET << std::endl;
	}
	else {
		if (amount > this->_hitPoints)
			amount = this->_hitPoints;
		this->_hitPoints -= amount;
		if (this->_hitPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_RED << this->_name << " has been destroyed! So much for warranty..." << RESET << std::endl;
		}
		else {
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << this->_name << " takes " << amount << " damage. Ouch!" << RESET << std::endl;
		}
	}
}

void FragTrap::beRepaired(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't be repaired!" << RESET << std::endl;
	}
	else {
		if (this->_energyPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to be repaired. Time for a recharge!" << RESET << std::endl;
			return ;
		}
		this->_hitPoints += amount;
		if (this->_hitPoints > 100)
			this->_hitPoints = 100;
		if (!this->_name.empty())
			std::cout << BOLD_BLUE << this->_name << " has been repaired for " << amount << " hit points!" << RESET << std::endl;
	}
}

void FragTrap::highFivesGuys(void) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't high five!" << RESET << std::endl;
	}
	else if (this->_energyPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to high five. Time for a recharge!" << RESET << std::endl;
	}
	else {
		std::cout << BOLD_CYAN << this->_name << " high fives the guys! ✋" << RESET << std::endl;
		this->_energyPoints -= 1;
	}
}

unsigned int FragTrap::getEnergyPoints(void) const {
	return this->_energyPoints;
}

unsigned int FragTrap::getAttackDamage(void) const {
	return this->_attackDamage;
}

unsigned int FragTrap::getHitPoints(void) const {
	return this->_hitPoints;
}#ifndef FRAGTRAP_HPP
# define FRAGTRAP_HPP

#include <iostream>
#include "ClapTrap.hpp"

class FragTrap : public virtual ClapTrap {
	public:
		FragTrap();
		FragTrap(FragTrap& copy);
		FragTrap(std::string name);
		FragTrap(std::string name, unsigned int hitPoints, unsigned int attackDamage);
		~FragTrap();
		void attack(const std::string& target);
		void takeDamage(unsigned int amount);
		void beRepaired(unsigned int amount);
		void highFivesGuys(void);
		unsigned int getEnergyPoints(void) const;
		unsigned int getAttackDamage(void) const;
		unsigned int getHitPoints(void) const;
};

#endif
#include "DiamondTrap.hpp"
#include "ClapTrap.hpp"
#include "ScavTrap.hpp"
#include "Colors.hpp"

int main(void) {
	DiamondTrap diamondTrap("bloublou");
	diamondTrap.whoAmI();
	diamondTrap.attack("zizi");
	diamondTrap.takeDamage(10);
	diamondTrap.beRepaired(10);
	return 0;
}NAME = program_ex03

SRC =   main.cpp \
        ClapTrap.cpp \
        ScavTrap.cpp \
        FragTrap.cpp \
        DiamondTrap.cpp \

OBJS_DIR = build
OBJS = $(addprefix $(OBJS_DIR)/, $(SRC:.cpp=.o))

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[0;33m
BLUE = \033[0;34m
VC = \033[0;35m
CYAN = \033[0;96m
DARK_GRAY = \033[0;90m
END = \033[0m

all: $(NAME)

$(NAME): $(OBJS)
	@$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)
	@echo "$(VC)$(NAME)$(END) compilation $(GREEN)OK$(END)"

$(OBJS_DIR)/%.o : %.cpp ClapTrap.hpp
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) -c $< -o $@
	@echo "$(CYAN)Compilation de $<$(END)"

clean:
	@rm -rf $(OBJS_DIR)
	@echo "$(YELLOW)Objets supprimés$(END)"

fclean: clean
	@rm -f $(NAME)
	@echo "$(RED)$(NAME) supprimé$(END)"

re: fclean all

.PHONY: all clean fclean re
#include "ScavTrap.hpp"
#include "Colors.hpp"

ScavTrap::ScavTrap() : ClapTrap() {
	std::cout << BOLD_GREEN << "Default constructor called. A new ScavTrap is born!" << RESET << std::endl;
	this->_hitPoints = 100;
	this->_energyPoints = 50;
	this->_attackDamage = 20;
}

ScavTrap::ScavTrap(unsigned int energyPoints) : ClapTrap() {
	std::cout << BOLD_GREEN << "Constructor called. A new ScavTrap is born!" << RESET << std::endl;
	this->_energyPoints = energyPoints;
}

ScavTrap::ScavTrap(std::string name) : ClapTrap() {
	std::cout << BOLD_GREEN << "Constructor for " << BOLD_CYAN << name << RESET << BOLD_GREEN << " called. A new ScavTrap is born! Ready to rumble!" << RESET << std::endl;
	this->_hitPoints = 100;
	this->_energyPoints = 50;
	this->_attackDamage = 20;
}

ScavTrap::ScavTrap(ScavTrap& copy) : ClapTrap(copy) {
	std::cout << BOLD_YELLOW << "Copy constructor called. Cloning Scav the " << BOLD_CYAN << copy._name << RESET << BOLD_YELLOW << "!" << RESET << std::endl;
}

ScavTrap::~ScavTrap() {
	std::cout << BOLD_RED << "Destructor called. ScavTrap signing off!" << RESET << std::endl;
}

void ScavTrap::attack(const std::string& target) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't attack!" << RESET << std::endl;
	}
	else if (this->_energyPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to attack. Time for a recharge!" << RESET << std::endl;
	}
	else {
		std::cout << BOLD_MAGENTA << this->_name << " attacks " << target << ", causing " << this->_attackDamage << " points of damage!" << RESET << std::endl;
		this->_energyPoints -= 1;
	}
}

void ScavTrap::takeDamage(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is already out. No need to kick a robot when it's down!" << RESET << std::endl;
	}
	else {
		if (amount > this->_hitPoints)
			amount = this->_hitPoints;
		this->_hitPoints -= amount;
		if (this->_hitPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_RED << this->_name << " has been destroyed! So much for warranty..." << RESET << std::endl;
		}
		else {
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << this->_name << " takes " << amount << " damage. Ouch!" << RESET << std::endl;
		}
	}
}

void ScavTrap::beRepaired(unsigned int amount) {
	if (this->_hitPoints <= 0){
		if (!this->_name.empty())
			std::cout << BOLD_RED << this->_name << " is out of commission and can't be repaired!" << RESET << std::endl;
	}
	else {
		if (this->_energyPoints <= 0){
			if (!this->_name.empty())
				std::cout << BOLD_YELLOW << "Not enough energy points for " << this->_name << " to be repaired. Time for a recharge!" << RESET << std::endl;
			return ;
		}
		this->_hitPoints += amount;
		if (this->_hitPoints > 100)
			this->_hitPoints = 100;
		if (!this->_name.empty())
			std::cout << BOLD_BLUE << this->_name << " has been repaired for " << amount << " hit points!" << RESET << std::endl;
	}
}

void ScavTrap::guardGate() {
	std::cout << BOLD_CYAN << this->_name << RESET << BOLD_CYAN << " has entered Gate Keeper mode!" << RESET << std::endl;
}

unsigned int ScavTrap::getEnergyPoints(void) const {
	return 100;
}#ifndef SCAVTRAP_HPP
# define SCAVTRAP_HPP

#include <iostream>
#include "ClapTrap.hpp"

class ScavTrap : public virtual ClapTrap {
	public:
		ScavTrap();
		ScavTrap(ScavTrap& copy);
		ScavTrap(std::string name);
		ScavTrap(unsigned int energyPoints);
		~ScavTrap();
		void attack(const std::string& target);
		void takeDamage(unsigned int amount);
		void beRepaired(unsigned int amount);
		void guardGate();
		unsigned int getEnergyPoints(void) const;

};

#endif
